import * as React from 'react';
import * as prismicH from '@prismicio/helpers';
import * as prismicR from '@prismicio/richtext';
import { Element } from '@prismicio/richtext';
export { Element } from '@prismicio/richtext';

const PrismicContext = React.createContext({});
const PrismicProvider = ({
  client,
  linkResolver,
  richTextComponents,
  internalLinkComponent,
  externalLinkComponent,
  children
}) => {
  const value = React.useMemo(() => ({
    client,
    linkResolver,
    richTextComponents,
    internalLinkComponent,
    externalLinkComponent
  }), [
    client,
    linkResolver,
    richTextComponents,
    internalLinkComponent,
    externalLinkComponent
  ]);
  return /* @__PURE__ */ React.createElement(PrismicContext.Provider, {
    value
  }, children);
};

const usePrismicContext = () => {
  return React.useContext(PrismicContext) || {};
};

if (typeof process === "undefined") {
  globalThis.process = { env: {} };
}
const __PRODUCTION__ = process.env.NODE_ENV === "production";

const prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (__PRODUCTION__) {
    throw new Error(prefix);
  }
  throw new Error(`${prefix}: ${message || ""}`);
}

const usePrismicClient = (explicitClient) => {
  const context = usePrismicContext();
  const client = explicitClient || (context == null ? void 0 : context.client);
  invariant(client, "A @prismicio/client is required to query documents. Provide a client to the hook or to a <PrismicProvider> higher in your component tree.");
  return client;
};

const isInternalURL = (url) => {
  const isInternal = /^(\/(?!\/)|#)/.test(url);
  const isSpecialLink = !isInternal && !/^https?:\/\//.test(url);
  return isInternal && !isSpecialLink;
};

const defaultInternalComponent = "a";
const defaultExternalComponent = "a";
const _PrismicLink = (props, ref) => {
  const context = usePrismicContext();
  const linkResolver = props.linkResolver || context.linkResolver;
  let href;
  if ("href" in props) {
    href = props.href;
  } else if ("document" in props && props.document) {
    href = prismicH.asLink(props.document, linkResolver);
  } else if ("field" in props && props.field) {
    href = prismicH.asLink(props.field, linkResolver);
  }
  const target = props.target || "field" in props && props.field && "target" in props.field && props.field.target || void 0;
  const rel = props.rel || (target === "_blank" ? "noopener noreferrer" : void 0);
  const InternalComponent = props.internalComponent || context.internalLinkComponent || defaultInternalComponent;
  const ExternalComponent = props.externalComponent || context.externalLinkComponent || defaultExternalComponent;
  const isInternal = href && isInternalURL(href);
  const Component = isInternal ? InternalComponent : ExternalComponent;
  const passthroughProps = Object.assign({}, props);
  delete passthroughProps.linkResolver;
  delete passthroughProps.internalComponent;
  delete passthroughProps.externalComponent;
  delete passthroughProps.rel;
  delete passthroughProps.target;
  if ("field" in passthroughProps) {
    delete passthroughProps.field;
  } else if ("document" in passthroughProps) {
    delete passthroughProps.document;
  } else if ("href" in passthroughProps) {
    delete passthroughProps.href;
  }
  return href ? /* @__PURE__ */ React.createElement(Component, {
    ...passthroughProps,
    ref,
    href,
    target,
    rel
  }) : null;
};
if (!__PRODUCTION__) {
  _PrismicLink.displayName = "PrismicLink";
}
const PrismicLink = React.forwardRef(_PrismicLink);

const PrismicText = (props) => {
  return React.useMemo(() => {
    if (prismicH.isFilled.richText(props.field)) {
      const text = prismicH.asText(props.field, props.separator);
      return /* @__PURE__ */ React.createElement(React.Fragment, null, text);
    } else {
      return props.fallback != null ? /* @__PURE__ */ React.createElement(React.Fragment, null, props.fallback) : null;
    }
  }, [props.field, props.fallback, props.separator]);
};

const createDefaultSerializer = (args) => prismicR.wrapMapSerializer({
  heading1: ({ children, key }) => /* @__PURE__ */ React.createElement("h1", {
    key
  }, children),
  heading2: ({ children, key }) => /* @__PURE__ */ React.createElement("h2", {
    key
  }, children),
  heading3: ({ children, key }) => /* @__PURE__ */ React.createElement("h3", {
    key
  }, children),
  heading4: ({ children, key }) => /* @__PURE__ */ React.createElement("h4", {
    key
  }, children),
  heading5: ({ children, key }) => /* @__PURE__ */ React.createElement("h5", {
    key
  }, children),
  heading6: ({ children, key }) => /* @__PURE__ */ React.createElement("h6", {
    key
  }, children),
  paragraph: ({ children, key }) => /* @__PURE__ */ React.createElement("p", {
    key
  }, children),
  preformatted: ({ node, key }) => /* @__PURE__ */ React.createElement("pre", {
    key
  }, node.text),
  strong: ({ children, key }) => /* @__PURE__ */ React.createElement("strong", {
    key
  }, children),
  em: ({ children, key }) => /* @__PURE__ */ React.createElement("em", {
    key
  }, children),
  listItem: ({ children, key }) => /* @__PURE__ */ React.createElement("li", {
    key
  }, children),
  oListItem: ({ children, key }) => /* @__PURE__ */ React.createElement("li", {
    key
  }, children),
  list: ({ children, key }) => /* @__PURE__ */ React.createElement("ul", {
    key
  }, children),
  oList: ({ children, key }) => /* @__PURE__ */ React.createElement("ol", {
    key
  }, children),
  image: ({ node, key }) => {
    var _a;
    const img = /* @__PURE__ */ React.createElement("img", {
      src: node.url,
      alt: (_a = node.alt) != null ? _a : void 0,
      "data-copyright": node.copyright ? node.copyright : void 0
    });
    return /* @__PURE__ */ React.createElement("p", {
      key,
      className: "block-img"
    }, node.linkTo ? /* @__PURE__ */ React.createElement(PrismicLink, {
      linkResolver: args.linkResolver,
      internalComponent: args.internalLinkComponent,
      externalComponent: args.externalLinkComponent,
      field: node.linkTo
    }, img) : img);
  },
  embed: ({ node, key }) => {
    var _a;
    return /* @__PURE__ */ React.createElement("div", {
      key,
      "data-oembed": node.oembed.embed_url,
      "data-oembed-type": node.oembed.type,
      "data-oembed-provider": node.oembed.provider_name,
      dangerouslySetInnerHTML: { __html: (_a = node.oembed.html) != null ? _a : "" }
    });
  },
  hyperlink: ({ node, children, key }) => /* @__PURE__ */ React.createElement(PrismicLink, {
    key,
    field: node.data,
    linkResolver: args.linkResolver,
    internalComponent: args.internalLinkComponent,
    externalComponent: args.externalLinkComponent
  }, children),
  label: ({ node, children, key }) => /* @__PURE__ */ React.createElement("span", {
    key,
    className: node.data.label
  }, children),
  span: ({ text, key }) => {
    const result = [];
    let i = 0;
    for (const line of text.split("\n")) {
      if (i > 0) {
        result.push(/* @__PURE__ */ React.createElement("br", {
          key: `${i}__break`
        }));
      }
      result.push(/* @__PURE__ */ React.createElement(React.Fragment, {
        key: `${i}__line`
      }, line));
      i++;
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, {
      key
    }, result);
  }
});
const PrismicRichText = (props) => {
  const context = usePrismicContext();
  return React.useMemo(() => {
    if (prismicH.isFilled.richText(props.field)) {
      const linkResolver = props.linkResolver || context.linkResolver;
      const serializer = prismicR.composeSerializers(typeof props.components === "object" ? prismicR.wrapMapSerializer(props.components) : props.components, typeof context.richTextComponents === "object" ? prismicR.wrapMapSerializer(context.richTextComponents) : context.richTextComponents, createDefaultSerializer({
        linkResolver,
        internalLinkComponent: props.internalLinkComponent,
        externalLinkComponent: props.externalLinkComponent
      }));
      const serialized = prismicR.serialize(props.field, (type, node, text, children, key) => {
        const result = serializer(type, node, text, children, key);
        if (React.isValidElement(result) && result.key == null) {
          return React.cloneElement(result, { key });
        } else {
          return result;
        }
      });
      return /* @__PURE__ */ React.createElement(React.Fragment, null, serialized);
    } else {
      return props.fallback != null ? /* @__PURE__ */ React.createElement(React.Fragment, null, props.fallback) : null;
    }
  }, [
    props.field,
    props.internalLinkComponent,
    props.externalLinkComponent,
    props.components,
    props.linkResolver,
    props.fallback,
    context.linkResolver,
    context.richTextComponents
  ]);
};

var version = "2.3.0";

const devMsg = (slug) => {
  return `https://prismic.dev/msg/react/v${version}/${slug}`;
};

const _PrismicImage = (props, ref) => {
  const {
    field,
    alt,
    fallbackAlt,
    imgixParams,
    widths,
    pixelDensities,
    ...restProps
  } = props;
  if (!__PRODUCTION__) {
    if (typeof alt === "string" && props.alt !== "") {
      console.warn(`[PrismicImage] The alt prop can only be used to declare an image as decorative by passing an empty string (alt=""). For more details, see ${devMsg("alt-must-be-an-empty-string")}`);
    }
    if (typeof fallbackAlt === "string" && fallbackAlt !== "") {
      console.warn(`[PrismicImage] The fallbackAlt prop can only be used to declare an image as decorative by passing an empty string (fallbackAlt=""). For more details, see ${devMsg("alt-must-be-an-empty-string")}`);
    }
    if (widths && pixelDensities) {
      console.warn(`[PrismicImage] Only one of "widths" or "pixelDensities" props can be provided. "widths" will be used in this case.`);
    }
  }
  if (prismicH.isFilled.imageThumbnail(field)) {
    let src;
    let srcSet;
    if (widths || !pixelDensities) {
      const res = prismicH.asImageWidthSrcSet(field, {
        ...imgixParams,
        widths: widths === "defaults" ? void 0 : widths
      });
      src = res.src;
      srcSet = res.srcset;
    } else if (pixelDensities) {
      const res = prismicH.asImagePixelDensitySrcSet(field, {
        ...imgixParams,
        pixelDensities: pixelDensities === "defaults" ? void 0 : pixelDensities
      });
      src = res.src;
      srcSet = res.srcset;
    }
    return /* @__PURE__ */ React.createElement("img", {
      ref,
      src,
      srcSet,
      alt: alt != null ? alt : field.alt || fallbackAlt,
      ...restProps
    });
  } else {
    return null;
  }
};
if (!__PRODUCTION__) {
  _PrismicImage.displayName = "PrismicImage";
}
const PrismicImage = React.forwardRef(_PrismicImage);

const pascalCase = (input) => {
  const camelCased = input.replace(/(?:-|_)(\w)/g, (_, c) => {
    return c ? c.toUpperCase() : "";
  });
  return camelCased[0].toUpperCase() + camelCased.slice(1);
};

const TODOSliceComponent = __PRODUCTION__ ? () => null : ({
  slice
}) => {
  const type = "slice_type" in slice ? slice.slice_type : slice.type;
  React.useEffect(() => {
    console.warn(`[SliceZone] Could not find a component for Slice type "${type}"`, slice);
  }, [slice, type]);
  return /* @__PURE__ */ React.createElement("section", {
    "data-slice-zone-todo-component": "",
    "data-slice-type": type
  }, "Could not find a component for Slice type \u201C", type, "\u201D");
};
const SliceZone = ({
  slices = [],
  components = {},
  resolver,
  defaultComponent = TODOSliceComponent,
  context = {}
}) => {
  const renderedSlices = React.useMemo(() => {
    return slices.map((slice, index) => {
      const type = "slice_type" in slice ? slice.slice_type : slice.type;
      let Comp = components[type] || defaultComponent;
      if (resolver) {
        const resolvedComp = resolver({
          slice,
          sliceName: pascalCase(type),
          i: index
        });
        if (resolvedComp) {
          Comp = resolvedComp;
        }
      }
      const key = `${index}-${JSON.stringify(slice)}`;
      return /* @__PURE__ */ React.createElement(Comp, {
        key,
        slice,
        index,
        slices,
        context
      });
    });
  }, [components, context, defaultComponent, slices, resolver]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, renderedSlices);
};

const PrismicToolbar = ({
  repositoryName,
  type = "new"
}) => {
  const src = `https://static.cdn.prismic.io/prismic.js?repo=${repositoryName}${type === "new" ? "&new=true" : ""}`;
  React.useEffect(() => {
    const existingScript = document.querySelector(`script[src="${src}"]`);
    if (!existingScript) {
      const script = document.createElement("script");
      script.src = src;
      script.defer = true;
      script.dataset.prismicToolbar = "";
      script.dataset.repositoryName = repositoryName;
      script.dataset.type = type;
      document.body.appendChild(script);
    }
  }, [repositoryName, type, src]);
  return null;
};

const reducer = (state, action) => {
  switch (action[0]) {
    case "start": {
      return { state: "loading" };
    }
    case "succeed": {
      return { state: "loaded", data: action[1] };
    }
    case "fail": {
      return {
        ...state,
        state: "failed",
        error: action[1]
      };
    }
  }
};
const initialState = {
  state: "idle"
};
const isParams = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
const useStatefulPrismicClientMethod = (methodName, args, explicitClient) => {
  const lastArg = args[args.length - 1];
  const {
    client: lastArgExplicitClient,
    skip,
    ...params
  } = isParams(lastArg) ? lastArg : {};
  const argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;
  const client = usePrismicClient(explicitClient || lastArgExplicitClient);
  const [state, dispatch] = React.useReducer(reducer, initialState);
  React.useEffect(() => {
    if (!skip) {
      {
        dispatch(["start"]);
      }
      client[methodName].call(client, ...argsWithoutParams, params).then((result) => {
        {
          dispatch(["succeed", result]);
        }
      }).catch((error) => {
        {
          dispatch(["fail", error]);
        }
      });
    }
  }, [
    client,
    methodName,
    skip,
    JSON.stringify(argsWithoutParams),
    JSON.stringify(params)
  ]);
  return React.useMemo(() => [
    state.data,
    {
      state: state.state,
      error: state.error
    }
  ], [state]);
};

const usePrismicPreviewResolver = (args = {}) => {
  const context = usePrismicContext();
  const linkResolver = args.linkResolver || context.linkResolver;
  const result = useStatefulPrismicClientMethod("resolvePreviewURL", [
    {
      linkResolver,
      defaultURL: args.defaultURL || "/",
      previewToken: args.previewToken,
      documentID: args.documentID
    }
  ], args.client);
  const [resolvedURL] = result;
  const { navigate } = args;
  React.useEffect(() => {
    if (resolvedURL && navigate) {
      navigate(resolvedURL);
    }
  }, [resolvedURL, navigate]);
  return result;
};

const usePrismicDocuments = (...args) => useStatefulPrismicClientMethod("get", args);
const useFirstPrismicDocument = (...args) => useStatefulPrismicClientMethod("getFirst", args);
const useAllPrismicDocumentsDangerously = (...args) => useStatefulPrismicClientMethod("dangerouslyGetAll", args);
const usePrismicDocumentByID = (...args) => useStatefulPrismicClientMethod("getByID", args);
const usePrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getByIDs", args);
const useAllPrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getAllByIDs", args);
const usePrismicDocumentByUID = (...args) => useStatefulPrismicClientMethod("getByUID", args);
const usePrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getByUIDs", args);
const useAllPrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getAllByUIDs", args);
const useSinglePrismicDocument = (...args) => useStatefulPrismicClientMethod("getSingle", args);
const usePrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getByType", args);
const useAllPrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getAllByType", args);
const usePrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getByTag", args);
const useAllPrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getAllByTag", args);
const usePrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getBySomeTags", args);
const useAllPrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getAllBySomeTags", args);
const usePrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getByEveryTag", args);
const useAllPrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getAllByEveryTag", args);

const Elements = Element;

export { Elements, PrismicImage, PrismicLink, PrismicProvider, PrismicRichText, PrismicText, PrismicToolbar, SliceZone, TODOSliceComponent, useAllPrismicDocumentsByEveryTag, useAllPrismicDocumentsByIDs, useAllPrismicDocumentsBySomeTags, useAllPrismicDocumentsByTag, useAllPrismicDocumentsByType, useAllPrismicDocumentsByUIDs, useAllPrismicDocumentsDangerously, useFirstPrismicDocument, usePrismicClient, usePrismicContext, usePrismicDocumentByID, usePrismicDocumentByUID, usePrismicDocuments, usePrismicDocumentsByEveryTag, usePrismicDocumentsByIDs, usePrismicDocumentsBySomeTags, usePrismicDocumentsByTag, usePrismicDocumentsByType, usePrismicDocumentsByUIDs, usePrismicPreviewResolver, useSinglePrismicDocument };
//# sourceMappingURL=index.js.map
